"""
Workbench Chat API - Stateless chat for development/testing
No sessions, no history persistence, just direct agent communication with trace support
"""
from fastapi import APIRouter, Depends, HTTPException, Header, status
from fastapi.responses import StreamingResponse
from pydantic import BaseModel
from typing import Optional, AsyncGenerator
from datetime import datetime
import httpx
import json
import time
import asyncio
import logging

from app.core.security import get_current_user
from app.core.database import async_session_maker, WorkbenchSession, get_db
from sqlalchemy import select, and_, delete
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy.orm import attributes

logger = logging.getLogger(__name__)
router = APIRouter()

class SystemEvent(BaseModel):
    """System event from agent (tool calls, agent transfers, etc.)"""
    event: str
    data: dict
    timestamp: str

class Message(BaseModel):
    """Individual message in conversation"""
    id: Optional[str] = None  # Message ID from frontend
    role: str  # 'user' or 'assistant' or 'system'
    content: str
    timestamp: Optional[str] = None  # Timestamp from frontend
    systemEvents: Optional[list[SystemEvent]] = None  # System events for this message

class WorkbenchMessage(BaseModel):
    """Message request for Workbench with conversation history (ADK and Agno)"""
    agent_id: int
    messages: list[Message] = []  # Array of messages for conversation context (ADK)
    session_id: Optional[str] = None  # Optional sessionId for agent-managed sessions (ADK)
    # Agno-specific fields
    content: Optional[str] = None  # Single message content for Agno
    selected_resource: Optional[str] = None  # team_id or agent_id for Agno framework

async def get_agent_trace_id(agent_id: int, token: str) -> Optional[str]:
    """
    Get agent's trace_id from Agent Service
    The trace_id is generated by Agent Service when the agent is created
    """
    try:
        async with httpx.AsyncClient(timeout=5.0) as client:
            response = await client.get(
                f"http://agent-service:8002/api/agents/{agent_id}",
                headers={"Authorization": f"Bearer {token}"}
            )
            if response.status_code == 200:
                agent_data = response.json()
                trace_id = agent_data.get("trace_id")
                logger.info(f"[Workbench] Retrieved trace_id for agent {agent_id}: {trace_id}")
                return trace_id
            else:
                logger.warning(f"[Workbench] Failed to get agent trace_id: {response.status_code}")
                return None
    except Exception as e:
        logger.error(f"[Workbench] Error getting agent trace_id: {e}")
        return None

async def get_agent_info(agent_id: int, token: str) -> Optional[dict]:
    """
    Get full agent info from Agent Service (framework, a2a_endpoint, trace_id, etc.)
    """
    try:
        async with httpx.AsyncClient(timeout=5.0) as client:
            response = await client.get(
                f"http://agent-service:8002/api/agents/{agent_id}",
                headers={"Authorization": f"Bearer {token}"}
            )
            if response.status_code == 200:
                return response.json()
            else:
                logger.warning(f"[Workbench] Failed to get agent info: {response.status_code}")
                return None
    except Exception as e:
        logger.error(f"[Workbench] Error getting agent info: {e}")
        return None

@router.post("/workbench/chat/stream")
async def workbench_chat_stream(
    request: WorkbenchMessage,
    current_user: dict = Depends(get_current_user),
    authorization: Optional[str] = Header(None)
):
    """
    Stream chat response from agent for Workbench mode (ADK and Agno)
    - ADK: Uses messages array with A2A JSON-RPC protocol
    - Agno: Uses content + selected_resource with multipart/form-data
    """
    user_id = current_user["username"]
    token = authorization.replace("Bearer ", "") if authorization else ""

    # Get full agent info (framework, endpoint, trace_id)
    agent_info = await get_agent_info(request.agent_id, token)
    if not agent_info:
        raise HTTPException(status_code=404, detail="Agent not found")

    framework = agent_info.get("framework", "ADK")
    agent_url = agent_info.get("a2a_endpoint")
    trace_id = agent_info.get("trace_id")

    if not agent_url:
        raise HTTPException(status_code=400, detail="Agent endpoint not configured")

    logger.info(f"[Workbench] Chat request: agent={request.agent_id}, framework={framework}, user={user_id}")

    # Branch based on framework
    if framework == "Agno":
        # Agno: Use content + selected_resource
        if not request.content:
            raise HTTPException(status_code=400, detail="content is required for Agno agents")

        return await _handle_agno_stream(request, agent_url, user_id, trace_id)

    else:  # ADK or other frameworks
        # ADK: Use messages array (existing logic)
        if not trace_id:
            raise HTTPException(status_code=404, detail="trace_id missing for ADK agent")

        if not request.messages:
            raise HTTPException(status_code=400, detail="messages array is required for ADK agents")

        session_info = f", session_id={request.session_id}" if request.session_id else " (no session)"
        logger.info(f"[Workbench] ADK: messages={len(request.messages)}, trace_id={trace_id}{session_info}")

        # Stream response from ADK agent (existing logic)
        async def event_stream() -> AsyncGenerator[str, None]:
            """Stream events from ADK agent"""
            yield f"data: {json.dumps({'type': 'stream_start', 'trace_id': trace_id})}\n\n"

            try:
                async for event in _stream_from_agent_a2a(agent_url, request.messages, trace_id, request.session_id):
                    if event["type"] == "text_token":
                        yield f"data: {json.dumps(event)}\n\n"

                yield f"data: {json.dumps({'type': 'stream_end'})}\n\n"

            except Exception as e:
                logger.error(f"[Workbench] Error streaming from ADK agent: {e}")
                error_event = {"type": "error", "message": str(e)}
                yield f"data: {json.dumps(error_event)}\n\n"

        return StreamingResponse(
            event_stream(),
            media_type="text/event-stream",
            headers={
                "Cache-Control": "no-cache",
                "Connection": "keep-alive",
                "X-Accel-Buffering": "no",
                "X-Trace-ID": trace_id
            }
        )

@router.get("/workbench/messages/{agent_id}")
async def get_workbench_messages(
    agent_id: int,
    current_user: dict = Depends(get_current_user),
    db: AsyncSession = Depends(get_db)
):
    """
    Get stored messages for user+agent combination
    """
    user_id = current_user["username"]

    # Find existing session
    result = await db.execute(
        select(WorkbenchSession).where(
            and_(
                WorkbenchSession.user_id == user_id,
                WorkbenchSession.agent_id == agent_id
            )
        )
    )
    session = result.scalar_one_or_none()

    if session:
        return {"messages": session.messages}
    return {"messages": []}

@router.post("/workbench/messages/{agent_id}")
async def save_workbench_messages(
    agent_id: int,
    messages: list[Message],
    current_user: dict = Depends(get_current_user),
    db: AsyncSession = Depends(get_db)
):
    """
    Save messages for user+agent combination
    """
    user_id = current_user["username"]

    # Find or create session
    result = await db.execute(
        select(WorkbenchSession).where(
            and_(
                WorkbenchSession.user_id == user_id,
                WorkbenchSession.agent_id == agent_id
            )
        )
    )
    session = result.scalar_one_or_none()

    # Convert messages to dict format for storage
    message_dicts = [
        {
            "id": msg.id or f"msg-{int(time.time() * 1000)}-{i}",
            "role": msg.role,
            "content": msg.content,
            "timestamp": msg.timestamp or datetime.utcnow().isoformat()
        }
        for i, msg in enumerate(messages)
    ]

    if session:
        # Update existing session
        session.messages = message_dicts
        session.updated_at = datetime.utcnow()
        attributes.flag_modified(session, "messages")
    else:
        # Create new session
        session = WorkbenchSession(
            user_id=user_id,
            agent_id=agent_id,
            messages=message_dicts
        )
        db.add(session)

    await db.commit()

    logger.info(f"[Workbench] Saved {len(messages)} messages for {user_id}, agent {agent_id}")
    return {"status": "success", "message_count": len(messages)}

class ClearRequest(BaseModel):
    """Request to clear workbench data"""
    agent_id: int

@router.post("/workbench/clear")
async def clear_workbench_data(
    request: ClearRequest,
    current_user: dict = Depends(get_current_user),
    authorization: Optional[str] = Header(None),
    db: AsyncSession = Depends(get_db)
):
    """
    Clear both chat history and trace data for the user+agent combination
    """
    user_id = current_user["username"]
    token = authorization.replace("Bearer ", "") if authorization else ""
    trace_id = await get_agent_trace_id(request.agent_id, token)

    if not trace_id:
        logger.warning(f"[Workbench] Could not retrieve trace_id for agent {request.agent_id}, skipping trace clear")
        # Continue to clear chat messages even if trace_id is not available

    # 1. Clear chat messages from database
    try:
        await db.execute(
            delete(WorkbenchSession).where(
                and_(
                    WorkbenchSession.user_id == user_id,
                    WorkbenchSession.agent_id == request.agent_id
                )
            )
        )
        await db.commit()
        logger.info(f"[Workbench] Cleared chat messages for {user_id}, agent {request.agent_id}")
    except Exception as e:
        logger.error(f"[Workbench] Error clearing chat messages: {e}")
        await db.rollback()

    # 2. Clear trace data from Tracing Service
    try:
        async with httpx.AsyncClient(timeout=5.0) as client:
            response = await client.delete(
                f"http://tracing-service:8004/api/tracing/traces/{trace_id}"
            )
            if response.status_code == 200:
                logger.info(f"[Workbench] Cleared trace data for {user_id}, agent {request.agent_id}")
                return {"status": "success", "message": "Chat and trace data cleared"}
            else:
                logger.warning(f"[Workbench] Failed to clear trace: {response.status_code}")
                return {"status": "partial", "message": "Chat cleared, but trace data may not be fully cleared"}
    except Exception as e:
        logger.error(f"[Workbench] Error clearing trace: {e}")
        return {"status": "partial", "message": "Chat cleared, but failed to clear trace data"}

async def _get_agent_url(agent_id: int, token: str) -> Optional[str]:
    """Get agent A2A URL from agent service"""
    try:
        async with httpx.AsyncClient(timeout=5.0) as client:
            response = await client.get(
                f"http://agent-service:8002/api/agents/{agent_id}",
                headers={"Authorization": f"Bearer {token}"}
            )
            if response.status_code == 200:
                agent_data = response.json()
                return agent_data.get("a2a_endpoint")
            return None
    except Exception as e:
        logger.error(f"[Workbench] Error getting agent URL: {e}")
        return None

async def _stream_from_agent_a2a(agent_url: str, messages: list[Message], trace_id: str, session_id: str = None):
    """
    Stream response from agent via A2A protocol (ADK agents)
    Passes sessionId to agent for agent-side session management
    """
    agent_url = agent_url.replace("localhost", "host.docker.internal").replace("127.0.0.1", "host.docker.internal")

    if not messages:
        raise ValueError("No messages provided")

    # Get current message (last in the list)
    current_message = messages[-1]

    # Build conversation history for backward compatibility
    conversation_history = []
    if len(messages) > 1:
        for msg in messages[:-1]:
            conversation_history.append({
                "role": msg.role,
                "content": msg.content
            })

    # Generate unique message ID
    message_id = f"msg-{int(time.time() * 1000)}"

    # Build message parts: include history context + current message
    message_parts = []

    # Add conversation history as context (if exists)
    if conversation_history:
        history_text = "Previous conversation:\n"
        for i, msg in enumerate(conversation_history, 1):
            role_label = "User" if msg["role"] == "user" else "Assistant"
            history_text += f"{role_label}: {msg['content']}\n"
        history_text += "\nCurrent question:\n"

        message_parts.append({
            "kind": "text",
            "text": history_text + current_message.content
        })
    else:
        message_parts.append({
            "kind": "text",
            "text": current_message.content
        })

    # Build A2A request with sessionId for agent-managed sessions
    a2a_request = {
        "jsonrpc": "2.0",
        "method": "message/send",
        "params": {
            "message": {
                "messageId": message_id,
                "role": "user",
                "parts": message_parts,
                "metadata": {
                    "trace_id": trace_id,
                    "has_history": len(conversation_history) > 0
                }
            }
        },
        "id": f"workbench-{trace_id}"
    }

    # Add sessionId to params if provided (for agent-managed sessions)
    if session_id:
        a2a_request["params"]["sessionId"] = session_id
        logger.info(f"[Workbench] Using agent-managed sessionId: {session_id}")

    logger.info(f"[Workbench] Sending message with {len(conversation_history)} history items")

    async with httpx.AsyncClient(timeout=300.0) as client:
        # A2A doesn't support streaming yet, use message/send (non-streaming)
        logger.info(f"[Workbench] Sending A2A request to {agent_url}")

        response = await client.post(
            agent_url,
            json=a2a_request,
            headers={
                "Content-Type": "application/json",
                "X-Trace-ID": trace_id
            }
        )

        response.raise_for_status()
        result_data = response.json()
        # Log full response for debugging
        logger.info(f"[Workbench] FULL Agent response: {json.dumps(result_data, indent=2)}")

        # Process non-streaming response
        if "result" in result_data:
            result = result_data["result"]
            logger.info(f"[Workbench] Result type: {type(result)}")
            if isinstance(result, dict):
                logger.info(f"[Workbench] Result keys: {list(result.keys())}")
                logger.info(f"[Workbench] has 'artifacts': {'artifacts' in result}, has 'status': {'status' in result}, has 'parts': {'parts' in result}, has 'history': {'history' in result}")

            # Handle artifacts format
            if isinstance(result, dict) and "artifacts" in result:
                logger.info(f"[Workbench] Processing artifacts: {len(result.get('artifacts', []))} artifacts")
                for artifact in result.get("artifacts", []):
                    for part in artifact.get("parts", []):
                        if part.get("kind") == "text":
                            text_content = part.get("text", "")
                            logger.info(f"[Workbench] Yielding text: {text_content[:100]}")
                            yield {"type": "text_token", "content": text_content}

            # Handle task status format
            elif isinstance(result, dict) and "status" in result:
                status_message = result.get("status", {}).get("message", {})
                if isinstance(status_message, dict) and "parts" in status_message:
                    for part in status_message.get("parts", []):
                        if part.get("kind") == "text":
                            yield {"type": "text_token", "content": part.get("text", "")}

            # Handle message format (most common for ADK agents)
            elif isinstance(result, dict) and "parts" in result:
                for part in result.get("parts", []):
                    if part.get("kind") == "text":
                        yield {"type": "text_token", "content": part.get("text", "")}

            # Handle A2A history format (ADK agents)
            elif isinstance(result, dict) and "history" in result:
                logger.info(f"[Workbench] Processing history format: {len(result.get('history', []))} messages")
                history = result.get("history", [])
                # Find the last assistant message in history
                for message in reversed(history):
                    if message.get("role") == "assistant" and message.get("kind") == "message":
                        for part in message.get("parts", []):
                            if part.get("kind") == "text":
                                text_content = part.get("text", "")
                                logger.info(f"[Workbench] Yielding text from history: {text_content[:100]}")
                                yield {"type": "text_token", "content": text_content}
                        break

        elif "error" in result_data:
            error = result_data["error"]
            raise Exception(f"Agent error: {error.get('message')}")


async def _handle_agno_stream(
    request: WorkbenchMessage,
    agent_url: str,
    user_id: str,
    trace_id: Optional[str]
) -> StreamingResponse:
    """
    Handle Agno framework streaming using multipart/form-data
    Agno uses team-based routing with direct SSE streaming
    """
    # Replace localhost with host.docker.internal for Docker network
    agent_url = agent_url.replace("localhost", "host.docker.internal").replace("127.0.0.1", "host.docker.internal")

    # Build Agno chat endpoint based on selected_resource
    # Agno uses team-based routing: {agent_url}/teams/{team_id}/runs
    if request.selected_resource:
        # Remove 'team_' prefix if exists, otherwise use as-is
        team_id = request.selected_resource.replace("team_", "") if request.selected_resource.startswith("team_") else request.selected_resource
        chat_endpoint = f"{agent_url.rstrip('/')}/teams/{team_id}/runs"
    else:
        # Default to direct endpoint (no team routing)
        chat_endpoint = f"{agent_url.rstrip('/')}/runs"

    logger.info(f"[Workbench] Agno endpoint: {chat_endpoint}")

    async def stream_generator():
        """Generator that forwards streaming response from Agno agent"""
        try:
            async with httpx.AsyncClient(timeout=300.0) as client:
                # Build message content with conversation history if provided
                message_content = request.content or ""

                if request.messages and len(request.messages) > 0:
                    history_text = "Previous conversation:\n"
                    for msg in request.messages:
                        role = "User" if msg.role == "user" else "Assistant"
                        history_text += f"{role}: {msg.content}\n"
                    message_content = f"{history_text}\nCurrent message:\n{message_content}"

                # Agno uses multipart/form-data
                form_data = {
                    "message": message_content,
                    "stream": "true",
                    "monitor": "true",
                    "user_id": user_id,
                }

                logger.info("=" * 80)
                logger.info(f"[Workbench] Sending Agno request:")
                logger.info(f"  Endpoint: {chat_endpoint}")
                logger.info(f"  Message length: {len(message_content)}")
                logger.info(f"  User: {user_id}")
                logger.info(f"  Form data: {form_data}")
                logger.info("=" * 80)

                # Start SSE streaming
                async with client.stream(
                    "POST",
                    chat_endpoint,
                    data=form_data,
                    files=[],  # Empty files list ensures multipart/form-data encoding
                    headers={"Accept": "text/event-stream"}
                ) as response:
                    logger.info(f"[Workbench] Agno response received: status={response.status_code}, headers={dict(response.headers)}")

                    if response.status_code != 200:
                        error_text = await response.aread()
                        logger.error(f"[Workbench] Agno agent returned error: {response.status_code} - {error_text}")
                        yield f"data: {json.dumps({'type': 'error', 'message': f'Agent returned error: {response.status_code}'})}\n\n"
                        return

                    # Stream start event with trace_id if available
                    if trace_id:
                        yield f"data: {json.dumps({'type': 'stream_start', 'trace_id': trace_id})}\n\n"
                    else:
                        yield f"data: {json.dumps({'type': 'stream_start'})}\n\n"

                    # Forward SSE events line-by-line from Agno agent
                    logger.info(f"[Workbench] Starting real-time SSE streaming from Agno agent")
                    async for line in response.aiter_lines():
                        # Forward ALL lines including empty ones (SSE event separators)
                        logger.debug(f"[Workbench] Agno SSE line: {line[:100] if line else '(empty)'}...")
                        yield f"{line}\n"

                    # Stream end event
                    yield f"data: {json.dumps({'type': 'stream_end'})}\n\n"
                    logger.info(f"[Workbench] Agno stream completed")

        except httpx.TimeoutException:
            logger.error(f"[Workbench] Agno stream timeout")
            yield f"data: {json.dumps({'type': 'error', 'message': 'Request timeout'})}\n\n"
        except Exception as e:
            logger.error(f"[Workbench] Error streaming from Agno agent: {e}")
            yield f"data: {json.dumps({'type': 'error', 'message': str(e)})}\n\n"

    return StreamingResponse(
        stream_generator(),
        media_type="text/event-stream",
        headers={
            "Cache-Control": "no-cache",
            "Connection": "keep-alive",
            "X-Accel-Buffering": "no",
            **({"X-Trace-ID": trace_id} if trace_id else {})
        }
    )