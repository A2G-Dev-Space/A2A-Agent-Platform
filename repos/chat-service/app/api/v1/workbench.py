"""
Workbench Chat API - Stateless chat for development/testing
No sessions, no history persistence, just direct agent communication with trace support
"""
from fastapi import APIRouter, Depends, HTTPException, Header, status
from fastapi.responses import StreamingResponse
from pydantic import BaseModel
from typing import Optional, AsyncGenerator
from datetime import datetime
import httpx
import json
import time
import asyncio
import logging

from app.core.security import get_current_user
from app.core.database import async_session_maker, WorkbenchSession, get_db
from sqlalchemy import select, and_, delete
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy.orm import attributes

logger = logging.getLogger(__name__)
router = APIRouter()

class Message(BaseModel):
    """Individual message in conversation"""
    id: Optional[str] = None  # Message ID from frontend
    role: str  # 'user' or 'assistant'
    content: str
    timestamp: Optional[str] = None  # Timestamp from frontend

class WorkbenchMessage(BaseModel):
    """Message request for Workbench with conversation history"""
    agent_id: int
    messages: list[Message]  # Array of messages for conversation context
    session_id: Optional[str] = None  # Optional sessionId for agent-managed sessions

async def get_agent_trace_id(agent_id: int, token: str) -> Optional[str]:
    """
    Get agent's trace_id from Agent Service
    The trace_id is generated by Agent Service when the agent is created
    """
    try:
        async with httpx.AsyncClient(timeout=5.0) as client:
            response = await client.get(
                f"http://agent-service:8002/api/agents/{agent_id}",
                headers={"Authorization": f"Bearer {token}"}
            )
            if response.status_code == 200:
                agent_data = response.json()
                trace_id = agent_data.get("trace_id")
                logger.info(f"[Workbench] Retrieved trace_id for agent {agent_id}: {trace_id}")
                return trace_id
            else:
                logger.warning(f"[Workbench] Failed to get agent trace_id: {response.status_code}")
                return None
    except Exception as e:
        logger.error(f"[Workbench] Error getting agent trace_id: {e}")
        return None

@router.post("/workbench/chat/stream")
async def workbench_chat_stream(
    request: WorkbenchMessage,
    current_user: dict = Depends(get_current_user),
    authorization: Optional[str] = Header(None)
):
    """
    Stream chat response from agent for Workbench mode
    Maintains conversation history within the session (client-managed)
    Uses trace_id from Agent Service (generated at agent creation)
    """
    user_id = current_user["username"]
    token = authorization.replace("Bearer ", "") if authorization else ""
    trace_id = await get_agent_trace_id(request.agent_id, token)

    if not trace_id:
        raise HTTPException(status_code=404, detail="Agent not found or trace_id missing")

    # Log session info
    session_info = f", session_id={request.session_id}" if request.session_id else " (no session)"
    logger.info(f"[Workbench] Chat request from {user_id} to agent {request.agent_id}, messages={len(request.messages)}, trace_id={trace_id}{session_info}")

    # Get agent URL
    agent_url = await _get_agent_url(request.agent_id, token)
    if not agent_url:
        raise HTTPException(status_code=404, detail="Agent not found")

    # Stream response from agent
    async def event_stream() -> AsyncGenerator[str, None]:
        """Stream events from agent"""
        yield f"data: {json.dumps({'type': 'stream_start', 'trace_id': trace_id})}\n\n"

        try:
            async for event in _stream_from_agent_a2a(agent_url, request.messages, trace_id, request.session_id):
                if event["type"] == "text_token":
                    yield f"data: {json.dumps(event)}\n\n"

            yield f"data: {json.dumps({'type': 'stream_end'})}\n\n"

        except Exception as e:
            logger.error(f"[Workbench] Error streaming from agent: {e}")
            error_event = {"type": "error", "message": str(e)}
            yield f"data: {json.dumps(error_event)}\n\n"

    return StreamingResponse(
        event_stream(),
        media_type="text/event-stream",
        headers={
            "Cache-Control": "no-cache",
            "Connection": "keep-alive",
            "X-Accel-Buffering": "no",
            "X-Trace-ID": trace_id  # Include trace_id in response header
        }
    )

@router.get("/workbench/messages/{agent_id}")
async def get_workbench_messages(
    agent_id: int,
    current_user: dict = Depends(get_current_user),
    db: AsyncSession = Depends(get_db)
):
    """
    Get stored messages for user+agent combination
    """
    user_id = current_user["username"]

    # Find existing session
    result = await db.execute(
        select(WorkbenchSession).where(
            and_(
                WorkbenchSession.user_id == user_id,
                WorkbenchSession.agent_id == agent_id
            )
        )
    )
    session = result.scalar_one_or_none()

    if session:
        return {"messages": session.messages}
    return {"messages": []}

@router.post("/workbench/messages/{agent_id}")
async def save_workbench_messages(
    agent_id: int,
    messages: list[Message],
    current_user: dict = Depends(get_current_user),
    db: AsyncSession = Depends(get_db)
):
    """
    Save messages for user+agent combination
    """
    user_id = current_user["username"]

    # Find or create session
    result = await db.execute(
        select(WorkbenchSession).where(
            and_(
                WorkbenchSession.user_id == user_id,
                WorkbenchSession.agent_id == agent_id
            )
        )
    )
    session = result.scalar_one_or_none()

    # Convert messages to dict format for storage
    message_dicts = [
        {
            "id": msg.id or f"msg-{int(time.time() * 1000)}-{i}",
            "role": msg.role,
            "content": msg.content,
            "timestamp": msg.timestamp or datetime.utcnow().isoformat()
        }
        for i, msg in enumerate(messages)
    ]

    if session:
        # Update existing session
        session.messages = message_dicts
        session.updated_at = datetime.utcnow()
        attributes.flag_modified(session, "messages")
    else:
        # Create new session
        session = WorkbenchSession(
            user_id=user_id,
            agent_id=agent_id,
            messages=message_dicts
        )
        db.add(session)

    await db.commit()

    logger.info(f"[Workbench] Saved {len(messages)} messages for {user_id}, agent {agent_id}")
    return {"status": "success", "message_count": len(messages)}

class ClearRequest(BaseModel):
    """Request to clear workbench data"""
    agent_id: int

@router.post("/workbench/clear")
async def clear_workbench_data(
    request: ClearRequest,
    current_user: dict = Depends(get_current_user),
    authorization: Optional[str] = Header(None),
    db: AsyncSession = Depends(get_db)
):
    """
    Clear both chat history and trace data for the user+agent combination
    """
    user_id = current_user["username"]
    token = authorization.replace("Bearer ", "") if authorization else ""
    trace_id = await get_agent_trace_id(request.agent_id, token)

    if not trace_id:
        logger.warning(f"[Workbench] Could not retrieve trace_id for agent {request.agent_id}, skipping trace clear")
        # Continue to clear chat messages even if trace_id is not available

    # 1. Clear chat messages from database
    try:
        await db.execute(
            delete(WorkbenchSession).where(
                and_(
                    WorkbenchSession.user_id == user_id,
                    WorkbenchSession.agent_id == request.agent_id
                )
            )
        )
        await db.commit()
        logger.info(f"[Workbench] Cleared chat messages for {user_id}, agent {request.agent_id}")
    except Exception as e:
        logger.error(f"[Workbench] Error clearing chat messages: {e}")
        await db.rollback()

    # 2. Clear trace data from Tracing Service
    try:
        async with httpx.AsyncClient(timeout=5.0) as client:
            response = await client.delete(
                f"http://tracing-service:8004/api/tracing/traces/{trace_id}"
            )
            if response.status_code == 200:
                logger.info(f"[Workbench] Cleared trace data for {user_id}, agent {request.agent_id}")
                return {"status": "success", "message": "Chat and trace data cleared"}
            else:
                logger.warning(f"[Workbench] Failed to clear trace: {response.status_code}")
                return {"status": "partial", "message": "Chat cleared, but trace data may not be fully cleared"}
    except Exception as e:
        logger.error(f"[Workbench] Error clearing trace: {e}")
        return {"status": "partial", "message": "Chat cleared, but failed to clear trace data"}

async def _get_agent_url(agent_id: int, token: str) -> Optional[str]:
    """Get agent A2A URL from agent service"""
    try:
        async with httpx.AsyncClient(timeout=5.0) as client:
            response = await client.get(
                f"http://agent-service:8002/api/agents/{agent_id}",
                headers={"Authorization": f"Bearer {token}"}
            )
            if response.status_code == 200:
                agent_data = response.json()
                return agent_data.get("a2a_endpoint")
            return None
    except Exception as e:
        logger.error(f"[Workbench] Error getting agent URL: {e}")
        return None

async def _stream_from_agent_a2a(agent_url: str, messages: list[Message], trace_id: str, session_id: str = None):
    """
    Stream response from agent via A2A protocol (ADK agents)
    Passes sessionId to agent for agent-side session management
    """
    agent_url = agent_url.replace("localhost", "host.docker.internal").replace("127.0.0.1", "host.docker.internal")

    if not messages:
        raise ValueError("No messages provided")

    # Get current message (last in the list)
    current_message = messages[-1]

    # Build conversation history for backward compatibility
    conversation_history = []
    if len(messages) > 1:
        for msg in messages[:-1]:
            conversation_history.append({
                "role": msg.role,
                "content": msg.content
            })

    # Generate unique message ID
    message_id = f"msg-{int(time.time() * 1000)}"

    # Build message parts: include history context + current message
    message_parts = []

    # Add conversation history as context (if exists)
    if conversation_history:
        history_text = "Previous conversation:\n"
        for i, msg in enumerate(conversation_history, 1):
            role_label = "User" if msg["role"] == "user" else "Assistant"
            history_text += f"{role_label}: {msg['content']}\n"
        history_text += "\nCurrent question:\n"

        message_parts.append({
            "kind": "text",
            "text": history_text + current_message.content
        })
    else:
        message_parts.append({
            "kind": "text",
            "text": current_message.content
        })

    # Build A2A request with sessionId for agent-managed sessions
    a2a_request = {
        "jsonrpc": "2.0",
        "method": "message/send",
        "params": {
            "message": {
                "messageId": message_id,
                "role": "user",
                "parts": message_parts,
                "metadata": {
                    "trace_id": trace_id,
                    "has_history": len(conversation_history) > 0
                }
            }
        },
        "id": f"workbench-{trace_id}"
    }

    # Add sessionId to params if provided (for agent-managed sessions)
    if session_id:
        a2a_request["params"]["sessionId"] = session_id
        logger.info(f"[Workbench] Using agent-managed sessionId: {session_id}")

    logger.info(f"[Workbench] Sending message with {len(conversation_history)} history items")

    async with httpx.AsyncClient(timeout=300.0) as client:
        # A2A doesn't support streaming yet, use message/send (non-streaming)
        logger.info(f"[Workbench] Sending A2A request to {agent_url}")

        response = await client.post(
            agent_url,
            json=a2a_request,
            headers={
                "Content-Type": "application/json",
                "X-Trace-ID": trace_id
            }
        )

        response.raise_for_status()
        result_data = response.json()
        # Log full response for debugging
        logger.info(f"[Workbench] FULL Agent response: {json.dumps(result_data, indent=2)}")

        # Process non-streaming response
        if "result" in result_data:
            result = result_data["result"]
            logger.info(f"[Workbench] Result type: {type(result)}")
            if isinstance(result, dict):
                logger.info(f"[Workbench] Result keys: {list(result.keys())}")
                logger.info(f"[Workbench] has 'artifacts': {'artifacts' in result}, has 'status': {'status' in result}, has 'parts': {'parts' in result}, has 'history': {'history' in result}")

            # Handle artifacts format
            if isinstance(result, dict) and "artifacts" in result:
                logger.info(f"[Workbench] Processing artifacts: {len(result.get('artifacts', []))} artifacts")
                for artifact in result.get("artifacts", []):
                    for part in artifact.get("parts", []):
                        if part.get("kind") == "text":
                            text_content = part.get("text", "")
                            logger.info(f"[Workbench] Yielding text: {text_content[:100]}")
                            yield {"type": "text_token", "content": text_content}

            # Handle task status format
            elif isinstance(result, dict) and "status" in result:
                status_message = result.get("status", {}).get("message", {})
                if isinstance(status_message, dict) and "parts" in status_message:
                    for part in status_message.get("parts", []):
                        if part.get("kind") == "text":
                            yield {"type": "text_token", "content": part.get("text", "")}

            # Handle message format (most common for ADK agents)
            elif isinstance(result, dict) and "parts" in result:
                for part in result.get("parts", []):
                    if part.get("kind") == "text":
                        yield {"type": "text_token", "content": part.get("text", "")}

            # Handle A2A history format (ADK agents)
            elif isinstance(result, dict) and "history" in result:
                logger.info(f"[Workbench] Processing history format: {len(result.get('history', []))} messages")
                history = result.get("history", [])
                # Find the last assistant message in history
                for message in reversed(history):
                    if message.get("role") == "assistant" and message.get("kind") == "message":
                        for part in message.get("parts", []):
                            if part.get("kind") == "text":
                                text_content = part.get("text", "")
                                logger.info(f"[Workbench] Yielding text from history: {text_content[:100]}")
                                yield {"type": "text_token", "content": text_content}
                        break

        elif "error" in result_data:
            error = result_data["error"]
            raise Exception(f"Agent error: {error.get('message')}")