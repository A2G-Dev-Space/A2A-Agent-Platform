"""
Shared utility functions for agent operations
"""
import httpx
import logging
from typing import Optional, List, AsyncGenerator, Dict, Any
import time
import json

logger = logging.getLogger(__name__)


async def get_agent_info(agent_id: int, token: str) -> Optional[Dict[str, Any]]:
    """
    Get full agent info from Agent Service (framework, a2a_endpoint, trace_id, etc.)

    Args:
        agent_id: Agent ID
        token: Authorization token

    Returns:
        Agent info dict or None if not found
    """
    try:
        async with httpx.AsyncClient(timeout=5.0) as client:
            response = await client.get(
                f"http://agent-service:8002/api/agents/{agent_id}",
                headers={"Authorization": f"Bearer {token}"}
            )
            if response.status_code == 200:
                return response.json()
            else:
                logger.warning(f"Failed to get agent info: {response.status_code}")
                return None
    except Exception as e:
        logger.error(f"Error getting agent info: {e}")
        return None


async def get_agent_trace_id(agent_id: int, token: str) -> Optional[str]:
    """
    Get agent's trace_id from Agent Service

    The trace_id is generated by Agent Service when the agent is created

    Args:
        agent_id: Agent ID
        token: Authorization token

    Returns:
        Trace ID string or None if not found
    """
    agent_info = await get_agent_info(agent_id, token)
    if agent_info:
        trace_id = agent_info.get("trace_id")
        logger.info(f"Retrieved trace_id for agent {agent_id}: {trace_id}")
        return trace_id
    return None


class Message:
    """Message model for type hints"""
    def __init__(self, id: Optional[str], role: str, content: str, timestamp: Optional[str] = None, systemEvents: Optional[list] = None):
        self.id = id
        self.role = role
        self.content = content
        self.timestamp = timestamp
        self.systemEvents = systemEvents


async def stream_from_agent_a2a(
    agent_url: str,
    messages: List[Message],
    trace_id: Optional[str],
    session_id: Optional[str] = None
) -> AsyncGenerator[Dict[str, Any], None]:
    """
    Stream response from agent via A2A protocol (ADK agents)

    Passes sessionId to agent for agent-side session management

    Args:
        agent_url: Agent endpoint URL
        messages: List of conversation messages
        trace_id: Trace ID for tracking
        session_id: Optional session ID for agent-managed sessions

    Yields:
        Event dictionaries with type and content
    """
    # Replace localhost with host.docker.internal for Docker network
    agent_url = agent_url.replace("localhost", "host.docker.internal").replace("127.0.0.1", "host.docker.internal")

    if not messages:
        raise ValueError("No messages provided")

    # Get current message (last in the list)
    current_message = messages[-1]

    # Build conversation history for backward compatibility
    conversation_history = []
    if len(messages) > 1:
        for msg in messages[:-1]:
            conversation_history.append({
                "role": msg.role,
                "content": msg.content
            })

    # Generate unique message ID
    message_id = f"msg-{int(time.time() * 1000)}"

    # Build message parts: include history context + current message
    message_parts = []

    # Add conversation history as context (if exists)
    if conversation_history:
        history_text = "Previous conversation:\n"
        for i, msg in enumerate(conversation_history, 1):
            role_label = "User" if msg["role"] == "user" else "Assistant"
            history_text += f"{role_label}: {msg['content']}\n"
        history_text += "\nCurrent question:\n"

        message_parts.append({
            "kind": "text",
            "text": history_text + current_message.content
        })
    else:
        message_parts.append({
            "kind": "text",
            "text": current_message.content
        })

    # Build A2A request with sessionId for agent-managed sessions
    a2a_request = {
        "jsonrpc": "2.0",
        "method": "message/send",
        "params": {
            "message": {
                "messageId": message_id,
                "role": "user",
                "parts": message_parts,
                "metadata": {
                    "trace_id": trace_id or "unknown",
                    "has_history": len(conversation_history) > 0
                }
            }
        },
        "id": f"chat-{trace_id or message_id}"
    }

    # Add sessionId to params if provided (for agent-managed sessions)
    if session_id:
        a2a_request["params"]["sessionId"] = session_id
        logger.info(f"Using agent-managed sessionId: {session_id}")

    logger.info(f"Sending message with {len(conversation_history)} history items")

    async with httpx.AsyncClient(timeout=300.0) as client:
        # A2A doesn't support streaming yet, use message/send (non-streaming)
        logger.info(f"Sending A2A request to {agent_url}")

        response = await client.post(
            agent_url,
            json=a2a_request,
            headers={
                "Content-Type": "application/json",
                "X-Trace-ID": trace_id or ""
            }
        )

        response.raise_for_status()
        result_data = response.json()
        # Log full response for debugging
        logger.info(f"FULL Agent response: {json.dumps(result_data, indent=2)}")

        # Process non-streaming response
        if "result" in result_data:
            result = result_data["result"]
            logger.info(f"Result type: {type(result)}")
            if isinstance(result, dict):
                logger.info(f"Result keys: {list(result.keys())}")
                logger.info(f"has 'artifacts': {'artifacts' in result}, has 'status': {'status' in result}, has 'parts': {'parts' in result}, has 'history': {'history' in result}")

            # Handle artifacts format
            if isinstance(result, dict) and "artifacts" in result:
                logger.info(f"Processing artifacts: {len(result.get('artifacts', []))} artifacts")
                for artifact in result.get("artifacts", []):
                    for part in artifact.get("parts", []):
                        if part.get("kind") == "text":
                            text_content = part.get("text", "")
                            logger.info(f"Yielding text: {text_content[:100]}")
                            yield {"type": "text_token", "content": text_content}

            # Handle task status format
            elif isinstance(result, dict) and "status" in result:
                status_message = result.get("status", {}).get("message", {})
                if isinstance(status_message, dict) and "parts" in status_message:
                    for part in status_message.get("parts", []):
                        if part.get("kind") == "text":
                            yield {"type": "text_token", "content": part.get("text", "")}

            # Handle message format (most common for ADK agents)
            elif isinstance(result, dict) and "parts" in result:
                for part in result.get("parts", []):
                    if part.get("kind") == "text":
                        yield {"type": "text_token", "content": part.get("text", "")}

            # Handle A2A history format (ADK agents)
            elif isinstance(result, dict) and "history" in result:
                logger.info(f"Processing history format: {len(result.get('history', []))} messages")
                history = result.get("history", [])
                # Find the last assistant message in history
                for message in reversed(history):
                    if message.get("role") == "assistant" and message.get("kind") == "message":
                        for part in message.get("parts", []):
                            if part.get("kind") == "text":
                                text_content = part.get("text", "")
                                logger.info(f"Yielding text from history: {text_content[:100]}")
                                yield {"type": "text_token", "content": text_content}
                        break

        elif "error" in result_data:
            error = result_data["error"]
            raise Exception(f"Agent error: {error.get('message')}")
